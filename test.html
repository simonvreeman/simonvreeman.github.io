<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Big Bang Simulation - Three.js Demo</title>
  <style>
    /* Remove default margins and ensure the canvas fills the viewport */
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- The demo code below uses ES6 modules -->
  <script type="module">
    // Import required modules from Three.js and its examples
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.150.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.150.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.150.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.150.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { BokehPass } from 'https://unpkg.com/three@0.150.0/examples/jsm/postprocessing/BokehPass.js';
    import { Lensflare, LensflareElement } from 'https://unpkg.com/three@0.150.0/examples/jsm/objects/Lensflare.js';

    // Global variables for the scene, camera, renderer, post-processing composer, and objects
    let scene, camera, renderer, composer, controls;
    let singularity, particleSystem;
    let startTime;
    let explosionTriggered = false; // Tracks whether the explosion has started

    // Bloom effect parameters
    const bloomParams = {
      bloomStrength: 1.5,
      bloomThreshold: 0,
      bloomRadius: 0.5
    };

    /**
     * Initializes the scene, camera, renderer, singularity, particle system, and post-processing.
     */
    function init() {
      // Create the scene and set a black background
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Set up a PerspectiveCamera with a 60° field-of-view
      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 50);

      // Create the WebGL renderer with antialiasing enabled
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Add OrbitControls for user interactivity
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Create the singularity (a pulsating bright sphere with a lens flare)
      createSingularity();

      // Create the particle system to represent the expanding cosmos (initially hidden)
      createParticleSystem();

      // Set up post-processing (bloom and depth-of-field)
      setupPostProcessing();

      // Listen for window resize events
      window.addEventListener('resize', onWindowResize, false);

      // Record the start time for animation timing
      startTime = performance.now();
    }

    /**
     * Creates a singularity—a small sphere with a custom shader for a pulsating effect.
     * A lens flare is attached to enhance its glowing appearance.
     */
    function createSingularity() {
      // Sphere geometry for the singularity
      const geometry = new THREE.SphereGeometry(1, 32, 32);

      // ShaderMaterial to produce a pulsating glow
      const material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0.0 },
          pulsateIntensity: { value: 1.0 }
        },
        vertexShader: `
          varying vec3 vPosition;
          void main() {
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform float pulsateIntensity;
          varying vec3 vPosition;
          void main() {
            // Use a sine wave to pulsate the brightness
            float intensity = abs(sin(time * 2.0)) * pulsateIntensity;
            // Create a radial gradient so the center glows more intensely
            float dist = length(vPosition);
            float alpha = 1.0 - smoothstep(0.0, 1.0, dist);
            gl_FragColor = vec4(vec3(1.0, 0.8, 0.5) * intensity, alpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending
      });
      singularity = new THREE.Mesh(geometry, material);
      scene.add(singularity);

      // --- Lens Flare Setup ---
      // Load textures for the lens flare elements
      const textureLoader = new THREE.TextureLoader();
      const textureFlare0 = textureLoader.load('https://threejs.org/examples/textures/lensflare/lensflare0.png');
      const textureFlare3 = textureLoader.load('https://threejs.org/examples/textures/lensflare/lensflare3.png');
      // Create a Lensflare object and add several flare elements for a subtle effect
      const lensflare = new Lensflare();
      lensflare.addElement(new LensflareElement(textureFlare0, 700, 0, new THREE.Color(0xffaacc)));
      lensflare.addElement(new LensflareElement(textureFlare3, 60, 0.6));
      lensflare.addElement(new LensflareElement(textureFlare3, 70, 0.7));
      lensflare.addElement(new LensflareElement(textureFlare3, 120, 0.9));
      // Attach the lens flare to the singularity
      singularity.add(lensflare);
    }

    /**
     * Creates a particle system to simulate the Big Bang explosion. Each particle is
     * given an initial velocity (in a random direction) and a warm, varied color.
     */
    function createParticleSystem() {
      const particleCount = 10000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      // Initialize every particle at the center (the singularity) with random velocity vectors
      for (let i = 0; i < particleCount; i++) {
        // Position: start at the origin
        positions[i * 3] = 0;
        positions[i * 3 + 1] = 0;
        positions[i * 3 + 2] = 0;

        // Determine a random direction using spherical coordinates
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const speed = Math.random() * 0.5 + 0.5;
        velocities[i * 3] = speed * Math.sin(phi) * Math.cos(theta);
        velocities[i * 3 + 1] = speed * Math.sin(phi) * Math.sin(theta);
        velocities[i * 3 + 2] = speed * Math.cos(phi);

        // Assign warm, cosmic colors with some randomness
        colors[i * 3] = 1.0;
        colors[i * 3 + 1] = 0.7 + Math.random() * 0.3;
        colors[i * 3 + 2] = 0.5 + Math.random() * 0.5;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      // Create a custom shader material for the particles
      const material = new THREE.ShaderMaterial({
        uniforms: {
          pointSize: { value: 2.0 },
          time: { value: 0.0 }
        },
        vertexShader: `
          // Pass the per-vertex color to the fragment shader
          attribute vec3 color;
          varying vec3 vColor;
          uniform float pointSize;
          void main() {
            vColor = color;
            // Calculate the transformed position and adjust point size based on distance
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = pointSize * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          uniform float time;
          void main() {
            // Create round points with smooth edges
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            gl_FragColor = vec4(vColor, 1.0);
          }
        `,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      particleSystem = new THREE.Points(geometry, material);
      // Keep the particle system hidden until the explosion is triggered
      particleSystem.visible = false;
      scene.add(particleSystem);
    }

    /**
     * Configures post-processing using EffectComposer to apply bloom and depth-of-field effects.
     */
    function setupPostProcessing() {
      composer = new EffectComposer(renderer);
      // First pass: render the scene normally
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);

      // Unreal Bloom Pass for a dramatic glow effect
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        bloomParams.bloomStrength,
        bloomParams.bloomRadius,
        bloomParams.bloomThreshold
      );
      composer.addPass(bloomPass);

      // Bokeh Pass for a subtle depth-of-field effect
      const bokehPass = new BokehPass(scene, camera, {
        focus: 15.0,
        aperture: 0.00002,
        maxblur: 0.01,
        width: window.innerWidth,
        height: window.innerHeight
      });
      composer.addPass(bokehPass);
    }

    /**
     * Adjusts the camera and renderer when the window is resized.
     */
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    /**
     * Triggers the Big Bang explosion: the singularity is hidden and the particle system becomes visible.
     */
    function triggerExplosion() {
      if (!explosionTriggered) {
        explosionTriggered = true;
        singularity.visible = false;
        particleSystem.visible = true;
        // Reset startTime so that particle movement timing starts at zero
        startTime = performance.now();
      }
    }

    /**
     * The main animation loop updates the singularity’s pulsation, moves particles outward,
     * updates controls, and renders the scene via the post-processing composer.
     */
    function animate() {
      requestAnimationFrame(animate);
      const elapsed = (performance.now() - startTime) / 1000; // elapsed time in seconds

      // If the singularity is still visible, update its pulsating effect
      if (singularity.visible) {
        singularity.material.uniforms.time.value = elapsed;
      }

      // After 3 seconds, trigger the explosion if not already started
      if (elapsed > 3 && !explosionTriggered) {
        triggerExplosion();
      }

      // If the explosion has been triggered, update particle positions
      if (explosionTriggered && particleSystem.visible) {
        const positions = particleSystem.geometry.attributes.position.array;
        const velocities = particleSystem.geometry.attributes.velocity.array;
        const particleCount = positions.length / 3;
        // Move each particle along its velocity vector
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] += velocities[i * 3] * 0.02;
          positions[i * 3 + 1] += velocities[i * 3 + 1] * 0.02;
          positions[i * 3 + 2] += velocities[i * 3 + 2] * 0.02;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
        // (Optional) Update the time uniform for further particle shader effects if needed
        particleSystem.material.uniforms.time.value = elapsed;
      }

      // Update camera controls and render the scene with post-processing effects
      controls.update();
      composer.render();
    }

    // Initialize everything and start the animation loop
    init();
    animate();
  </script>
</body>
</html>